---
layout: post
title: "一对好基友，深度优先vs.广度优先"
tags: 算法, BFS, DFS
---

# 一对好基友，深度优先vs.广度优先

##广度优先搜索

BFS是树或者图的遍历策略，该算法(从树的根结点 or 从图的任意节点)出发, 先搜遍所有的邻居节点，然后再拓展到下一层级，

如下图，BFS结果是:

[1], [2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]

![tree-breadth-first-search]({{site.static}}/images/tree-breadth-first-search.jpg)



深度优先搜索

DFS也是树或者图的遍历策略，与BFS策略相反，该算法(从树的根结点 or 从图的任意节点)出发，在回溯之前探索尽可能远

如下图：DFS结果是:

[1, 2, 3, 4], [1, 2, 3,5], [1, 2,6], [1,7], [1,8, 9, 10], [1, 8, 9,11], [1, 8 ,12]


回溯是指，先遍历[1, 2, 3, 4], 然后4没有更深的节点，然后把4丢掉，退回[1, 2, 3],，再把5填到结果中得到[1, 2, 3, 5]，以此类推







DFS递归实现

def DFS_Recursive(self, root):
    def DFS_Helper(result, node):
        #do something
        result.append(node)
        for sub in node.children:
            DFS_Helper(result, sub)
    result = []
    DFS_Helper(result, root)
    return result


BFS && DFS非递归实现

```
def BFS_NonRecursive(self, root):
    result = []
    queue = [root]
    while(len(queue) > 0):
        node = queue.pop(0) # line 5 pop first
        # do something
        result.append(node)
        for sub in node.children:
            queue.append(sub)
    return result
```

通常BFS不使用递归来实现，如果你执意如此，就当个思考练习吧


```
def DFS_NonRecursive(self, root):
    result = []
    queue = [root]
    while(len(queue) > 0):
        node = queue.pop() # line 5 pop last
        # do something
        result.append(node)
        for sub in node.children:
            queue.append(sub)
    return result
```

如果你仔细观察，非递归版本BFS与DFS只有第5行不一样，BFS使用的是队列, DFS使用的是栈



--END--