---
layout: post
title: "32. 最长有效括号(Longest Valid Parentheses)"
categories: Leetcode
tags: String Dynamic-programming
excerpt: ""
---

* content
{:toc}

## 32. Longest Valid Parentheses

给定一个只包含 '(' 和 ')' 的字符串，找出最长的包含有效括号的子串的长度。

示例 1:

```
输入: "(()"
输出: 2
解释: 最长有效括号子串为 "()"
```

示例 2:

```
输入: ")()())"
输出: 4
解释: 最长有效括号子串为 "()()"
```

## 暴力破解

O(N^3)

字符串的子串，有N^2个，然后依据[20. Valid Parentheses](http://geemaple.github.io/2020/07/28/leetcode-20/)来判断每一个子串是否有效, 每次判断时间复杂度O(N)

### 优化的暴力破解

O(N^2)

```
match == 0, # 代表已经全部匹配, 记录下答案
match > 0,  # 代表还有未匹配的左括号'('数量
match < 0,  # 代表左括号不足的数量，也就是right > left， 例如-1代表有括号')'多了一个
```

代码如下：

```python
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        
        res = 0
        n = len(s)
        match = 0
            
        for i in range(len(s)):
            start = i
            for j in range(i, len(s)):
                if i == j:
                    match = 1 if s[j] == '(' else -1
                    
                elif s[j] == '(':
                    if match >= 0:
                        match += 1 
                    else:
                        start = j
                        match = 1
                elif s[j] == ')':
                    match -= 1
                    if match == 0 and j - start + 1 > res:
                        res = j - start  + 1

        return res
```

## 两遍扫描

以')()())'为例，图解一下上述优化的暴力破解的过程

```                            
 )    (    )    (    )    )
-1    1    0    1    0   -1     # i = 0, 已经算出答案
      1    0    1    0   -1     # i = 1, ❌重复计算
           -1   1    0   -1     # i = 2, ❌更短, 无需计算
                1    0   -1     # i = 3, ❌更短, 无需计算
                    -1   -2     # i = 4, ❌更短, 无需计算
                         -1     # i = 5, ❌更短, 无需计算         
# j = [i, len(s))
```

但是有一种情况例外，解决方案是反向扫描一遍

```
(    (    (    (    )
1    2    3    4    3     # 此时match不等于0, ❌拿不到答案
```

代码用**left+right**书写，比较直观清晰：

```python
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        
        res = 0
        # 从左到右
        left = right = 0    
        for i in range(len(s)):
            if s[i] == '(':
                left += 1
            else:
                right += 1

            if left == right and right * 2 > res:
                res = right * 2
            elif right > left:
                left = right = 0

        # 从右到左
        left = right = 0   
        for i in range(len(s))[::-1]:
            if s[i] == ')':
                right += 1
            else:
                left += 1

            if left == right and right * 2 > res:
                res = right * 2
            elif left > right:
                left = right = 0

        return res
```

## 栈

对于上述两遍扫描，可以用一个变量来**match**来存储**left+right**括号的比较情况, match其实就是一个特殊的栈, 

真正的栈包含更多的存储信息，可以解决上述corner case:

首先: 栈可以消除最近匹配的两个括号'()'

其次: 在栈底部，留一个哨兵**index = -1**，用来计算开始start字符

最后: 每一个多余的左括号'('的下标, 或者栈为空右括号')'的下标，都成了新的哨兵

```python
class Solution:
    def longestValidParentheses(self, s: str) -> int:
        
        res = 0
        stack = [-1]
        
        for i in range(len(s)):
            if s[i] == '(':
                stack.append(i)
            else:
                stack.pop()
                if len(stack) == 0: #如果栈为空，说明右括号多了，那么右括号的index作为新的哨兵
                    stack.append(i)
                else:
                    if i - stack[-1] > res:
                        res = i - stack[-1]
                    
        return res
```

## 动态规划

// TBD，太难了，学不动了


--End--


