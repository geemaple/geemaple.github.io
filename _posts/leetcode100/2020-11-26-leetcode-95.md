---
layout: post
title: "LeetCode-95.不同的二叉搜索树 II(Unique Binary Search Trees II)"
categories: Leetcode
tags: Dynamic-Programming Tree
excerpt: ""
---

* content
{:toc}

## 95. 不同的二叉搜索树 II

给定一个整数 n，生成所有由 1 ... n 为节点所组成的 二叉搜索树 。

示例：

```
输入：3
输出：
[
  [1,null,3,2],
  [3,2,null,1],
  [3,1,null,null,2],
  [2,1,3],
  [1,null,2,null,3]
]
解释：
以上的输出对应以下 5 种不同结构的二叉搜索树：

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
```

提示：

0 <= n <= 8

来源：力扣（LeetCode）

链接：[https://leetcode-cn.com/problems/unique-binary-search-trees-ii](https://leetcode-cn.com/problems/unique-binary-search-trees-ii)

Link：[https://leetcode.com/problems/unique-binary-search-trees-ii/](https://leetcode.com/problems/unique-binary-search-trees-ii/)

## 异类

本来一道题目，找出所有的答案，那肯定是DFS了

**但是**, 对于[2, 1, 3], [2, 3, 1], 会组成同一颗BST

⚠️以下代码，虽然是个❌错误答案❌，但感觉有助于理解题目本身, 它本身的问题是既没办法去重复(即记忆化搜索)，也没办法状态推导

树的深拷贝，虽然有专门的一道题，值得练习一下

```python
from collections import deque
class Solution:
    def generateTrees(self, n: int) -> List[TreeNode]:
        
        res = []
        self.helper(n, set(), res, None)
        return res
        
    def helper(self, n : int, visited: set, res: List[TreeNode], root: TreeNode):
        
        if len(visited) == n:
            res.append(root)
            return
        
        for i in range(1, n + 1):
            if i in visited:
                continue
                
            node = TreeNode(i)
            visited.add(i)
            tree = self.copyTree(root)
            tree = self.attachNode(node, tree)
            self.helper(n, visited, res, tree)
            visited.remove(i)
                
    def copyTree(self, root: TreeNode):
        
        if root is None:
            return None
        
        mapping = {}      
        queue = deque([root])
        mapping[root] = TreeNode(root.val)
        
        while len(queue) > 0:
            node = queue.popleft()
            if node.left is not None:
                left = TreeNode(node.left.val)
                mapping[node].left = left
                mapping[node.left] = left
                queue.append(node.left)
                
            if node.right is not None:
                right = TreeNode(node.right.val)
                mapping[node].right = right
                mapping[node.right] = right
                queue.append(node.right)        
        
        return mapping[root]        
                
    def attachNode(self, node: TreeNode, root: TreeNode):
        
        if root is None:
            return node
        
        cur = root
        while cur is not None:
            if node.val > cur.val:
                if cur.right is not None:
                    cur = cur.right
                else:
                    cur.right = node
                    break
                    
            if node.val < cur.val:
                if cur.left is not None:
                    cur = cur.left
                else:
                    cur.left = node
                    break
        
        return root
```

## 动态规划

//TBD


--End--
